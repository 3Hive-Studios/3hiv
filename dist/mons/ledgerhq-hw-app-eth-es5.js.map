{"version":3,"sources":["webpack:///node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js","webpack:///node_modules/@ledgerhq/hw-app-eth/lib-es/utils.js"],"names":["hexBuffer","str","Buffer","from","startsWith","slice","maybeHexBuffer","remapTransactionRelatedErrors","e","statusCode","Eth","transport","scrambleKey","decorateAppAPIMethods","path","boolDisplay","boolChaincode","paths","buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","response","result","publicKeyLength","addressLength","publicKey","toString","address","chainCode","data","rawTxHex","offset","rawTx","toSend","rlpTx","rlpOffset","rlpVrs","maxChunkSize","chunkSize","copy","push","i","apduResponse","v","r","s","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","version","messageHex","message","domainSeparatorHex","hashStructMessageHex","domainSeparator","hashStruct","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","padStart","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","operationContract","operationQuantization","operationContractHex","defer","resolve","reject","promise","Promise","success","failure","splitPath","components","split","number","parseInt","isNaN","eachSeries","arr","fun","reduce","p","foreach","callback","iterate","array","res","doIf","condition","asyncWhile","predicate"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAMA,iBAASA,SAAT,CAAmBC,GAAnB,EAAwB;AACtB,iBAAOC,MAAM,CAACC,IAAP,CAAYF,GAAG,CAACG,UAAJ,CAAe,IAAf,IAAuBH,GAAG,CAACI,KAAJ,CAAU,CAAV,CAAvB,GAAsCJ,GAAlD,EAAuD,KAAvD,CAAP;AACD;;AAED,iBAASK,cAAT,CAAwBL,GAAxB,EAA6B;AAC3B,cAAI,CAACA,GAAL,EAAU,OAAO,IAAP;AACV,iBAAOD,SAAS,CAACC,GAAD,CAAhB;AACD;;AAED,YAAMM,6BAA6B,GAAG,SAAhCA,6BAAgC,CAAAC,CAAC,EAAI;AACzC,cAAIA,CAAC,IAAIA,CAAC,CAACC,UAAF,KAAiB,MAA1B,EAAkC;AAChC,mBAAO,IAAI,+EAAJ,CAAmC,0DAAnC,CAAP;AACD;;AAED,iBAAOD,CAAP;AACD,SAND;AAOA;;;;;;;;;AAtCA,YA+CqBE,GA/CrB;AAgDE,uBAAYC,SAAZ,EAA4C;AAAA,gBAArBC,WAAqB,uEAAP,KAAO;;AAAA;;AAC1C,iBAAKD,SAAL,GAAiB,KAAK,CAAtB;AACA,iBAAKA,SAAL,GAAiBA,SAAjB;AACAA,qBAAS,CAACE,qBAAV,CAAgC,IAAhC,EAAsC,CAAC,YAAD,EAAe,8BAAf,EAA+C,iBAA/C,EAAkE,qBAAlE,EAAyF,qBAAzF,EAAgH,mBAAhH,EAAqI,gBAArI,EAAuJ,mBAAvJ,EAA4K,qBAA5K,CAAtC,EAA0OD,WAA1O;AACD;AACD;;;;;;;;;;;AArDF;AAAA;AAAA,uCAgEaE,IAhEb,EAgEmBC,WAhEnB,EAgEgCC,aAhEhC,EAgE+C;AAC3C,kBAAIC,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAII,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAIF,KAAK,CAACG,MAAN,GAAe,CAAhC,CAAb;AACAF,oBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,mBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,sBAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,eAFD;AAGA,qBAAO,KAAKZ,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgCV,WAAW,GAAG,IAAH,GAAU,IAArD,EAA2DC,aAAa,GAAG,IAAH,GAAU,IAAlF,EAAwFE,MAAxF,EAAgGQ,IAAhG,CAAqG,UAAAC,QAAQ,EAAI;AACtH,oBAAIC,MAAM,GAAG,EAAb;AACA,oBAAIC,eAAe,GAAGF,QAAQ,CAAC,CAAD,CAA9B;AACA,oBAAIG,aAAa,GAAGH,QAAQ,CAAC,IAAIE,eAAL,CAA5B;AACAD,sBAAM,CAACG,SAAP,GAAmBJ,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,IAAIwB,eAAtB,EAAuCG,QAAvC,CAAgD,KAAhD,CAAnB;AACAJ,sBAAM,CAACK,OAAP,GAAiB,OAAON,QAAQ,CAACtB,KAAT,CAAe,IAAIwB,eAAJ,GAAsB,CAArC,EAAwC,IAAIA,eAAJ,GAAsB,CAAtB,GAA0BC,aAAlE,EAAiFE,QAAjF,CAA0F,OAA1F,CAAxB;;AAEA,oBAAIhB,aAAJ,EAAmB;AACjBY,wBAAM,CAACM,SAAP,GAAmBP,QAAQ,CAACtB,KAAT,CAAe,IAAIwB,eAAJ,GAAsB,CAAtB,GAA0BC,aAAzC,EAAwD,IAAID,eAAJ,GAAsB,CAAtB,GAA0BC,aAA1B,GAA0C,EAAlG,EAAsGE,QAAtG,CAA+G,KAA/G,CAAnB;AACD;;AAED,uBAAOJ,MAAP;AACD,eAZM,CAAP;AAaD;AACD;;;;;;;;;;;;;;;;AArFF;AAAA;AAAA,+DAwGK;AAAA,kBADDO,IACC,QADDA,IACC;AACD,qBAAO,KAAKxB,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4CU,IAA5C,EAAkDT,IAAlD,CAAuD;AAAA,uBAAM,IAAN;AAAA,eAAvD,EAAmE,UAAAlB,CAAC,EAAI;AAC7E,oBAAIA,CAAC,IAAIA,CAAC,CAACC,UAAF,KAAiB,MAA1B,EAAkC;AAChC;AACA;AACA,yBAAO,KAAP;AACD;;AAED,sBAAMD,CAAN;AACD,eARM,CAAP;AASD;AACD;;;;;;AAnHF;AAAA;AAAA,4CA0HkBM,IA1HlB,EA0HwBsB,QA1HxB,EA0HkC;AAAA;;AAC9B,kBAAInB,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAIuB,MAAM,GAAG,CAAb;AACA,kBAAIC,KAAK,GAAGpC,MAAM,CAACC,IAAP,CAAYiC,QAAZ,EAAsB,KAAtB,CAAZ;AACA,kBAAIG,MAAM,GAAG,EAAb;AACA,kBAAIZ,QAAJ,CAL8B,CAKhB;;AAEd,kBAAIa,KAAK,GAAG,mDAAOF,KAAP,CAAZ;AACA,kBAAIG,SAAS,GAAG,CAAhB;;AAEA,kBAAID,KAAK,CAACpB,MAAN,GAAe,CAAnB,EAAsB;AACpB,oBAAIsB,MAAM,GAAG,mDAAOF,KAAK,CAACnC,KAAN,CAAY,CAAC,CAAb,CAAP,CAAb;AACAoC,yBAAS,GAAGH,KAAK,CAAClB,MAAN,IAAgBsB,MAAM,CAACtB,MAAP,GAAgB,CAAhC,CAAZ;AACD;;AAb6B;AAgB5B,oBAAIuB,YAAY,GAAGN,MAAM,KAAK,CAAX,GAAe,MAAM,CAAN,GAAUpB,KAAK,CAACG,MAAN,GAAe,CAAxC,GAA4C,GAA/D;AACA,oBAAIwB,SAAS,GAAGP,MAAM,GAAGM,YAAT,GAAwBL,KAAK,CAAClB,MAA9B,GAAuCkB,KAAK,CAAClB,MAAN,GAAeiB,MAAtD,GAA+DM,YAA/E;;AAEA,oBAAIF,SAAS,IAAI,CAAb,IAAkBJ,MAAM,GAAGO,SAAT,IAAsBH,SAA5C,EAAuD;AACrD;AACAG,2BAAS;AACV;;AAED,oBAAI1B,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAakB,MAAM,KAAK,CAAX,GAAe,IAAIpB,KAAK,CAACG,MAAN,GAAe,CAAnB,GAAuBwB,SAAtC,GAAkDA,SAA/D,CAAb;;AAEA,oBAAIP,MAAM,KAAK,CAAf,EAAkB;AAChBnB,wBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,uBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,0BAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,mBAFD;AAGAe,uBAAK,CAACO,IAAN,CAAW3B,MAAX,EAAmB,IAAI,IAAID,KAAK,CAACG,MAAjC,EAAyCiB,MAAzC,EAAiDA,MAAM,GAAGO,SAA1D;AACD,iBAND,MAMO;AACLN,uBAAK,CAACO,IAAN,CAAW3B,MAAX,EAAmB,CAAnB,EAAsBmB,MAAtB,EAA8BA,MAAM,GAAGO,SAAvC;AACD;;AAEDL,sBAAM,CAACO,IAAP,CAAY5B,MAAZ;AACAmB,sBAAM,IAAIO,SAAV;AArC4B;;AAe9B,qBAAOP,MAAM,KAAKC,KAAK,CAAClB,MAAxB,EAAgC;AAAA;AAuB/B;;AAED,qBAAO,uDAAQmB,MAAR,EAAgB,UAACJ,IAAD,EAAOY,CAAP;AAAA,uBAAa,KAAI,CAACpC,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgCsB,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiB,IAAjD,EAAuD,IAAvD,EAA6DZ,IAA7D,EAAmET,IAAnE,CAAwE,UAAAsB,YAAY,EAAI;AAC1HrB,0BAAQ,GAAGqB,YAAX;AACD,iBAFmC,CAAb;AAAA,eAAhB,EAEHtB,IAFG,CAEE,YAAM;AACb,oBAAMuB,CAAC,GAAGtB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,CAAlB,EAAqB2B,QAArB,CAA8B,KAA9B,CAAV;AACA,oBAAMkB,CAAC,GAAGvB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,IAAI,EAAtB,EAA0B2B,QAA1B,CAAmC,KAAnC,CAAV;AACA,oBAAMmB,CAAC,GAAGxB,QAAQ,CAACtB,KAAT,CAAe,IAAI,EAAnB,EAAuB,IAAI,EAAJ,GAAS,EAAhC,EAAoC2B,QAApC,CAA6C,KAA7C,CAAV;AACA,uBAAO;AACLiB,mBAAC,EAADA,CADK;AAELC,mBAAC,EAADA,CAFK;AAGLC,mBAAC,EAADA;AAHK,iBAAP;AAKD,eAXM,EAWJ,UAAA3C,CAAC,EAAI;AACN,sBAAMD,6BAA6B,CAACC,CAAD,CAAnC;AACD,eAbM,CAAP;AAcD;AACD;;;AAjLF;AAAA;AAAA,kDAqLwB;AACpB,qBAAO,KAAKG,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4CC,IAA5C,CAAiD,UAAAC,QAAQ,EAAI;AAClE,oBAAIC,MAAM,GAAG,EAAb;AACAA,sBAAM,CAACwB,oBAAP,GAA8BzB,QAAQ,CAAC,CAAD,CAAR,GAAc,IAA5C;AACAC,sBAAM,CAACyB,0BAAP,GAAoC1B,QAAQ,CAAC,CAAD,CAAR,GAAc,IAAlD;AACAC,sBAAM,CAAC0B,YAAP,GAAsB3B,QAAQ,CAAC,CAAD,CAAR,GAAc,IAApC;AACAC,sBAAM,CAAC2B,OAAP,GAAiB,KAAK5B,QAAQ,CAAC,CAAD,CAAb,GAAmB,GAAnB,GAAyBA,QAAQ,CAAC,CAAD,CAAjC,GAAuC,GAAvC,GAA6CA,QAAQ,CAAC,CAAD,CAAtE;AACA,uBAAOC,MAAP;AACD,eAPM,CAAP;AAQD;AACD;;;;;;;;;;;;;AA/LF;AAAA;AAAA,gDA6MsBd,IA7MtB,EA6M4B0C,UA7M5B,EA6MwC;AAAA;;AACpC,kBAAIvC,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAIuB,MAAM,GAAG,CAAb;AACA,kBAAIoB,OAAO,GAAGvD,MAAM,CAACC,IAAP,CAAYqD,UAAZ,EAAwB,KAAxB,CAAd;AACA,kBAAIjB,MAAM,GAAG,EAAb;AACA,kBAAIZ,QAAJ;;AALoC;AAQlC,oBAAIgB,YAAY,GAAGN,MAAM,KAAK,CAAX,GAAe,MAAM,CAAN,GAAUpB,KAAK,CAACG,MAAN,GAAe,CAAzB,GAA6B,CAA5C,GAAgD,GAAnE;AACA,oBAAIwB,SAAS,GAAGP,MAAM,GAAGM,YAAT,GAAwBc,OAAO,CAACrC,MAAhC,GAAyCqC,OAAO,CAACrC,MAAR,GAAiBiB,MAA1D,GAAmEM,YAAnF;AACA,oBAAIzB,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAakB,MAAM,KAAK,CAAX,GAAe,IAAIpB,KAAK,CAACG,MAAN,GAAe,CAAnB,GAAuB,CAAvB,GAA2BwB,SAA1C,GAAsDA,SAAnE,CAAb;;AAEA,oBAAIP,MAAM,KAAK,CAAf,EAAkB;AAChBnB,wBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,uBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,0BAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,mBAFD;AAGAL,wBAAM,CAACM,aAAP,CAAqBiC,OAAO,CAACrC,MAA7B,EAAqC,IAAI,IAAIH,KAAK,CAACG,MAAnD;AACAqC,yBAAO,CAACZ,IAAR,CAAa3B,MAAb,EAAqB,IAAI,IAAID,KAAK,CAACG,MAAd,GAAuB,CAA5C,EAA+CiB,MAA/C,EAAuDA,MAAM,GAAGO,SAAhE;AACD,iBAPD,MAOO;AACLa,yBAAO,CAACZ,IAAR,CAAa3B,MAAb,EAAqB,CAArB,EAAwBmB,MAAxB,EAAgCA,MAAM,GAAGO,SAAzC;AACD;;AAEDL,sBAAM,CAACO,IAAP,CAAY5B,MAAZ;AACAmB,sBAAM,IAAIO,SAAV;AAxBkC;;AAOpC,qBAAOP,MAAM,KAAKoB,OAAO,CAACrC,MAA1B,EAAkC;AAAA;AAkBjC;;AAED,qBAAO,uDAAQmB,MAAR,EAAgB,UAACJ,IAAD,EAAOY,CAAP;AAAA,uBAAa,MAAI,CAACpC,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgCsB,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiB,IAAjD,EAAuD,IAAvD,EAA6DZ,IAA7D,EAAmET,IAAnE,CAAwE,UAAAsB,YAAY,EAAI;AAC1HrB,0BAAQ,GAAGqB,YAAX;AACD,iBAFmC,CAAb;AAAA,eAAhB,EAEHtB,IAFG,CAEE,YAAM;AACb,oBAAMuB,CAAC,GAAGtB,QAAQ,CAAC,CAAD,CAAlB;AACA,oBAAMuB,CAAC,GAAGvB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,IAAI,EAAtB,EAA0B2B,QAA1B,CAAmC,KAAnC,CAAV;AACA,oBAAMmB,CAAC,GAAGxB,QAAQ,CAACtB,KAAT,CAAe,IAAI,EAAnB,EAAuB,IAAI,EAAJ,GAAS,EAAhC,EAAoC2B,QAApC,CAA6C,KAA7C,CAAV;AACA,uBAAO;AACLiB,mBAAC,EAADA,CADK;AAELC,mBAAC,EAADA,CAFK;AAGLC,mBAAC,EAADA;AAHK,iBAAP;AAKD,eAXM,CAAP;AAYD;AACD;;;;;;;;;;;;;AArPF;AAAA;AAAA,oDAmQ0BrC,IAnQ1B,EAmQgC4C,kBAnQhC,EAmQoDC,oBAnQpD,EAmQ0E;AACtE,kBAAMC,eAAe,GAAG5D,SAAS,CAAC0D,kBAAD,CAAjC;AACA,kBAAMG,UAAU,GAAG7D,SAAS,CAAC2D,oBAAD,CAA5B;AACA,kBAAI1C,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAII,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAIF,KAAK,CAACG,MAAN,GAAe,CAAnB,GAAuB,EAAvB,GAA4B,EAAzC,EAA6C,CAA7C,CAAb;AACA,kBAAIiB,MAAM,GAAG,CAAb;AACAnB,oBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,mBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,sBAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,eAFD;AAGAc,oBAAM,GAAG,IAAI,IAAIpB,KAAK,CAACG,MAAvB;AACAwC,6BAAe,CAACf,IAAhB,CAAqB3B,MAArB,EAA6BmB,MAA7B;AACAA,oBAAM,IAAI,EAAV;AACAwB,wBAAU,CAAChB,IAAX,CAAgB3B,MAAhB,EAAwBmB,MAAxB;AACA,qBAAO,KAAK1B,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4CP,MAA5C,EAAoDQ,IAApD,CAAyD,UAAAC,QAAQ,EAAI;AAC1E,oBAAMsB,CAAC,GAAGtB,QAAQ,CAAC,CAAD,CAAlB;AACA,oBAAMuB,CAAC,GAAGvB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,IAAI,EAAtB,EAA0B2B,QAA1B,CAAmC,KAAnC,CAAV;AACA,oBAAMmB,CAAC,GAAGxB,QAAQ,CAACtB,KAAT,CAAe,IAAI,EAAnB,EAAuB,IAAI,EAAJ,GAAS,EAAhC,EAAoC2B,QAApC,CAA6C,KAA7C,CAAV;AACA,uBAAO;AACLiB,mBAAC,EAADA,CADK;AAELC,mBAAC,EAADA,CAFK;AAGLC,mBAAC,EAADA;AAHK,iBAAP;AAKD,eATM,CAAP;AAUD;AACD;;;;;;;AA5RF;AAAA;AAAA,8CAoSoBrC,IApSpB,EAoS0BC,WApS1B,EAoSuC;AACnC,kBAAIE,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAII,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAIF,KAAK,CAACG,MAAN,GAAe,CAAhC,CAAb;AACAF,oBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,mBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,sBAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,eAFD;AAGA,qBAAO,KAAKZ,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgCV,WAAW,GAAG,IAAH,GAAU,IAArD,EAA2D,IAA3D,EAAiEG,MAAjE,EAAyEQ,IAAzE,CAA8E,UAAAC,QAAQ,EAAI;AAC/F,uBAAOA,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkBsB,QAAQ,CAACP,MAAT,GAAkB,CAApC,CAAP;AACD,eAFM,CAAP;AAGD;AACD;;;;;;;;;;;;;;;;AA/SF;AAAA;AAAA,2CAgUiBN,IAhUjB,EAgUuBgD,kBAhUvB,EAgU2CC,kBAhU3C,EAgU+DC,uBAhU/D,EAgUwFC,uBAhUxF,EAgUiHC,WAhUjH,EAgU8HC,gBAhU9H,EAgUgJC,UAhUhJ,EAgU4JC,SAhU5J,EAgUuKC,KAhUvK,EAgU8KC,SAhU9K,EAgUyL;AACrL,kBAAMC,qBAAqB,GAAGlE,cAAc,CAACwD,kBAAD,CAA5C;AACA,kBAAMW,0BAA0B,GAAGnE,cAAc,CAAC0D,uBAAD,CAAjD;AACA,kBAAI/C,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAII,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAIF,KAAK,CAACG,MAAN,GAAe,CAAnB,GAAuB,EAAvB,GAA4B,EAA5B,GAAiC,EAAjC,GAAsC,EAAtC,GAA2C,CAA3C,GAA+C,CAA/C,GAAmD,CAAnD,GAAuD,CAAvD,GAA2D,CAA3D,GAA+D,CAA5E,EAA+E,CAA/E,CAAb;AACA,kBAAIiB,MAAM,GAAG,CAAb;AACAnB,oBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,mBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,sBAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,eAFD;AAGAc,oBAAM,GAAG,IAAI,IAAIpB,KAAK,CAACG,MAAvB;;AAEA,kBAAIoD,qBAAJ,EAA2B;AACzBA,qCAAqB,CAAC3B,IAAtB,CAA2B3B,MAA3B,EAAmCmB,MAAnC;AACD;;AAEDA,oBAAM,IAAI,EAAV;AACAnC,oBAAM,CAACC,IAAP,CAAY4D,kBAAkB,CAAC/B,QAAnB,CAA4B,EAA5B,EAAgC0C,QAAhC,CAAyC,EAAzC,EAA6C,GAA7C,CAAZ,EAA+D,KAA/D,EAAsE7B,IAAtE,CAA2E3B,MAA3E,EAAmFmB,MAAnF;AACAA,oBAAM,IAAI,EAAV;;AAEA,kBAAIoC,0BAAJ,EAAgC;AAC9BA,0CAA0B,CAAC5B,IAA3B,CAAgC3B,MAAhC,EAAwCmB,MAAxC;AACD;;AAEDA,oBAAM,IAAI,EAAV;AACAnC,oBAAM,CAACC,IAAP,CAAY8D,uBAAuB,CAACjC,QAAxB,CAAiC,EAAjC,EAAqC0C,QAArC,CAA8C,EAA9C,EAAkD,GAAlD,CAAZ,EAAoE,KAApE,EAA2E7B,IAA3E,CAAgF3B,MAAhF,EAAwFmB,MAAxF;AACAA,oBAAM,IAAI,EAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB0C,WAArB,EAAkC7B,MAAlC;AACAA,oBAAM,IAAI,CAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB2C,gBAArB,EAAuC9B,MAAvC;AACAA,oBAAM,IAAI,CAAV;AACAnC,oBAAM,CAACC,IAAP,CAAYiE,UAAU,CAACpC,QAAX,CAAoB,EAApB,EAAwB0C,QAAxB,CAAiC,EAAjC,EAAqC,GAArC,CAAZ,EAAuD,KAAvD,EAA8D7B,IAA9D,CAAmE3B,MAAnE,EAA2EmB,MAA3E;AACAA,oBAAM,IAAI,CAAV;AACAnC,oBAAM,CAACC,IAAP,CAAYkE,SAAS,CAACrC,QAAV,CAAmB,EAAnB,EAAuB0C,QAAvB,CAAgC,EAAhC,EAAoC,GAApC,CAAZ,EAAsD,KAAtD,EAA6D7B,IAA7D,CAAkE3B,MAAlE,EAA0EmB,MAA1E;AACAA,oBAAM,IAAI,CAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB8C,KAArB,EAA4BjC,MAA5B;AACAA,oBAAM,IAAI,CAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB+C,SAArB,EAAgClC,MAAhC;AACA,qBAAO,KAAK1B,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4CP,MAA5C,EAAoDQ,IAApD,CAAyD,UAAAC,QAAQ,EAAI;AAC1E,oBAAMuB,CAAC,GAAGvB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,IAAI,EAAtB,EAA0B2B,QAA1B,CAAmC,KAAnC,CAAV;AACA,oBAAMmB,CAAC,GAAGxB,QAAQ,CAACtB,KAAT,CAAe,IAAI,EAAnB,EAAuB,IAAI,EAAJ,GAAS,EAAhC,EAAoC2B,QAApC,CAA6C,KAA7C,CAAV;AACA,uBAAO;AACLkB,mBAAC,EAADA,CADK;AAELC,mBAAC,EAADA;AAFK,iBAAP;AAID,eAPM,CAAP;AAQD;AACD;;;;;;;;;;;;;;AA/WF;AAAA;AAAA,8CA8XoBrC,IA9XpB,EA8X0B6D,oBA9X1B,EA8XgDC,oBA9XhD,EA8XsEC,eA9XtE,EA8XuFX,WA9XvF,EA8XoGC,gBA9XpG,EA8XsHW,cA9XtH,EA8XsIR,KA9XtI,EA8X6IC,SA9X7I,EA8XwJ;AACpJ,kBAAMQ,uBAAuB,GAAGzE,cAAc,CAACqE,oBAAD,CAA9C;AACA,kBAAMK,kBAAkB,GAAGhF,SAAS,CAAC6E,eAAD,CAApC;AACA,kBAAI5D,KAAK,GAAG,yDAAUH,IAAV,CAAZ;AACA,kBAAII,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAIF,KAAK,CAACG,MAAN,GAAe,CAAnB,GAAuB,EAAvB,GAA4B,EAA5B,GAAiC,EAAjC,GAAsC,CAAtC,GAA0C,CAA1C,GAA8C,CAA9C,GAAkD,CAAlD,GAAsD,CAAnE,EAAsE,CAAtE,CAAb;AACA,kBAAIiB,MAAM,GAAG,CAAb;AACAnB,oBAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACG,MAAlB;AACAH,mBAAK,CAACI,OAAN,CAAc,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChCL,sBAAM,CAACM,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,eAFD;AAGAc,oBAAM,GAAG,IAAI,IAAIpB,KAAK,CAACG,MAAvB;;AAEA,kBAAI2D,uBAAJ,EAA6B;AAC3BA,uCAAuB,CAAClC,IAAxB,CAA6B3B,MAA7B,EAAqCmB,MAArC;AACD;;AAEDA,oBAAM,IAAI,EAAV;AACAnC,oBAAM,CAACC,IAAP,CAAYyE,oBAAoB,CAAC5C,QAArB,CAA8B,EAA9B,EAAkC0C,QAAlC,CAA2C,EAA3C,EAA+C,GAA/C,CAAZ,EAAiE,KAAjE,EAAwE7B,IAAxE,CAA6E3B,MAA7E,EAAqFmB,MAArF;AACAA,oBAAM,IAAI,EAAV;AACA2C,gCAAkB,CAACnC,IAAnB,CAAwB3B,MAAxB,EAAgCmB,MAAhC;AACAA,oBAAM,IAAI,EAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB0C,WAArB,EAAkC7B,MAAlC;AACAA,oBAAM,IAAI,CAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB2C,gBAArB,EAAuC9B,MAAvC;AACAA,oBAAM,IAAI,CAAV;AACAnC,oBAAM,CAACC,IAAP,CAAY2E,cAAc,CAAC9C,QAAf,CAAwB,EAAxB,EAA4B0C,QAA5B,CAAqC,EAArC,EAAyC,GAAzC,CAAZ,EAA2D,KAA3D,EAAkE7B,IAAlE,CAAuE3B,MAAvE,EAA+EmB,MAA/E;AACAA,oBAAM,IAAI,CAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB8C,KAArB,EAA4BjC,MAA5B;AACAA,oBAAM,IAAI,CAAV;AACAnB,oBAAM,CAACM,aAAP,CAAqB+C,SAArB,EAAgClC,MAAhC;AACA,qBAAO,KAAK1B,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4CP,MAA5C,EAAoDQ,IAApD,CAAyD,UAAAC,QAAQ,EAAI;AAC1E,oBAAMuB,CAAC,GAAGvB,QAAQ,CAACtB,KAAT,CAAe,CAAf,EAAkB,IAAI,EAAtB,EAA0B2B,QAA1B,CAAmC,KAAnC,CAAV;AACA,oBAAMmB,CAAC,GAAGxB,QAAQ,CAACtB,KAAT,CAAe,IAAI,EAAnB,EAAuB,IAAI,EAAJ,GAAS,EAAhC,EAAoC2B,QAApC,CAA6C,KAA7C,CAAV;AACA,uBAAO;AACLkB,mBAAC,EAADA,CADK;AAELC,mBAAC,EAADA;AAFK,iBAAP;AAID,eAPM,CAAP;AAQD;AACD;;;;;;;;;AAraF;AAAA;AAAA,gDA+asB8B,iBA/atB,EA+ayCC,qBA/azC,EA+agE;AAC5D,kBAAMC,oBAAoB,GAAG7E,cAAc,CAAC2E,iBAAD,CAA3C;AACA,kBAAI/D,MAAM,GAAGhB,MAAM,CAACiB,KAAP,CAAa,KAAK,EAAlB,EAAsB,CAAtB,CAAb;;AAEA,kBAAIgE,oBAAJ,EAA0B;AACxBA,oCAAoB,CAACtC,IAArB,CAA0B3B,MAA1B,EAAkC,CAAlC;AACD;;AAEDhB,oBAAM,CAACC,IAAP,CAAY+E,qBAAqB,CAAClD,QAAtB,CAA+B,EAA/B,EAAmC0C,QAAnC,CAA4C,EAA5C,EAAgD,GAAhD,CAAZ,EAAkE,KAAlE,EAAyE7B,IAAzE,CAA8E3B,MAA9E,EAAsF,EAAtF;AACA,qBAAO,KAAKP,SAAL,CAAec,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4CP,MAA5C,EAAoDQ,IAApD,CAAyD;AAAA,uBAAM,IAAN;AAAA,eAAzD,EAAqE,UAAAlB,CAAC,EAAI;AAC/E,oBAAIA,CAAC,IAAIA,CAAC,CAACC,UAAF,KAAiB,MAA1B,EAAkC;AAChC;AACA,yBAAO,KAAP;AACD;;AAED,sBAAMD,CAAN;AACD,eAPM,CAAP;AAQD;AAhcH;;AAAA;AAAA,aAmcA;;;;OAncA,E,IAAA,C,IAAA,E;;oBAAA;;;;;;;;;;;;;;;;ACAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAgBO,eAAS4E,KAAT,GAAiB;AACtB,YAAIC,OAAJ,EAAaC,MAAb;AACA,YAAIC,OAAO,GAAG,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,OAAnB,EAA4B;AACpDL,iBAAO,GAAGI,OAAV;AACAH,gBAAM,GAAGI,OAAT;AACD,SAHa,CAAd;AAIA,YAAI,CAACL,OAAD,IAAY,CAACC,MAAjB,EAAyB,MAAM,eAAN,CANH,CAM0B;;AAEhD,eAAO;AACLC,iBAAO,EAAPA,OADK;AAELF,iBAAO,EAAPA,OAFK;AAGLC,gBAAM,EAANA;AAHK,SAAP;AAKD,O,CAAC;;;AAEK,eAASK,SAAT,CAAmB7E,IAAnB,EAAyB;AAC9B,YAAIc,MAAM,GAAG,EAAb;AACA,YAAIgE,UAAU,GAAG9E,IAAI,CAAC+E,KAAL,CAAW,GAAX,CAAjB;AACAD,kBAAU,CAACvE,OAAX,CAAmB,UAAAC,OAAO,EAAI;AAC5B,cAAIwE,MAAM,GAAGC,QAAQ,CAACzE,OAAD,EAAU,EAAV,CAArB;;AAEA,cAAI0E,KAAK,CAACF,MAAD,CAAT,EAAmB;AACjB,mBADiB,CACT;AACT;;AAED,cAAIxE,OAAO,CAACF,MAAR,GAAiB,CAAjB,IAAsBE,OAAO,CAACA,OAAO,CAACF,MAAR,GAAiB,CAAlB,CAAP,KAAgC,GAA1D,EAA+D;AAC7D0E,kBAAM,IAAI,UAAV;AACD;;AAEDlE,gBAAM,CAACkB,IAAP,CAAYgD,MAAZ;AACD,SAZD;AAaA,eAAOlE,MAAP;AACD,O,CAAC;;;AAEK,eAASqE,UAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;AACnC,eAAOD,GAAG,CAACE,MAAJ,CAAW,UAACC,CAAD,EAAI7F,CAAJ;AAAA,iBAAU6F,CAAC,CAAC3E,IAAF,CAAO;AAAA,mBAAMyE,GAAG,CAAC3F,CAAD,CAAT;AAAA,WAAP,CAAV;AAAA,SAAX,EAA2CgF,OAAO,CAACH,OAAR,EAA3C,CAAP;AACD;;AACM,eAASiB,OAAT,CAAiBJ,GAAjB,EAAsBK,QAAtB,EAAgC;AACrC,iBAASC,OAAT,CAAiBjF,KAAjB,EAAwBkF,KAAxB,EAA+B7E,MAA/B,EAAuC;AACrC,cAAIL,KAAK,IAAIkF,KAAK,CAACrF,MAAnB,EAA2B;AACzB,mBAAOQ,MAAP;AACD,WAFD,MAEO,OAAO2E,QAAQ,CAACE,KAAK,CAAClF,KAAD,CAAN,EAAeA,KAAf,CAAR,CAA8BG,IAA9B,CAAmC,UAAUgF,GAAV,EAAe;AAC9D9E,kBAAM,CAACkB,IAAP,CAAY4D,GAAZ;AACA,mBAAOF,OAAO,CAACjF,KAAK,GAAG,CAAT,EAAYkF,KAAZ,EAAmB7E,MAAnB,CAAd;AACD,WAHa,CAAP;AAIR;;AAED,eAAO4D,OAAO,CAACH,OAAR,GAAkB3D,IAAlB,CAAuB;AAAA,iBAAM8E,OAAO,CAAC,CAAD,EAAIN,GAAJ,EAAS,EAAT,CAAb;AAAA,SAAvB,CAAP;AACD;;AACM,eAASS,IAAT,CAAcC,SAAd,EAAyBL,QAAzB,EAAmC;AACxC,eAAOf,OAAO,CAACH,OAAR,GAAkB3D,IAAlB,CAAuB,YAAM;AAClC,cAAIkF,SAAJ,EAAe;AACb,mBAAOL,QAAQ,EAAf;AACD;AACF,SAJM,CAAP;AAKD;;AACM,eAASM,UAAT,CAAoBC,SAApB,EAA+BP,QAA/B,EAAyC;AAC9C,iBAASC,OAAT,CAAiB5E,MAAjB,EAAyB;AACvB,cAAI,CAACkF,SAAS,EAAd,EAAkB;AAChB,mBAAOlF,MAAP;AACD,WAFD,MAEO;AACL,mBAAO2E,QAAQ,GAAG7E,IAAX,CAAgB,UAAAgF,GAAG,EAAI;AAC5B9E,oBAAM,CAACkB,IAAP,CAAY4D,GAAZ;AACA,qBAAOF,OAAO,CAAC5E,MAAD,CAAd;AACD,aAHM,CAAP;AAID;AACF;;AAED,eAAO4D,OAAO,CAACH,OAAR,CAAgB,EAAhB,EAAoB3D,IAApB,CAAyB8E,OAAzB,CAAP;AACD,O,CACD","file":"ledgerhq-hw-app-eth-es5.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\n\nfunction hexBuffer(str) {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str) {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\"Please enable Contract data on the Ethereum app Settings\");\n  }\n\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\n\nexport default class Eth {\n  constructor(transport, scrambleKey = \"w0w\") {\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\", \"starkGetPublicKey\", \"starkSignOrder\", \"starkSignTransfer\", \"starkProvideQuantum\"], scrambleKey);\n  }\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n\n  getAddress(path, boolDisplay, boolChaincode) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(response => {\n      let result = {};\n      let publicKeyLength = response[0];\n      let addressLength = response[1 + publicKeyLength];\n      result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      result.address = \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n\n      if (boolChaincode) {\n        result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n      }\n\n      return result;\n    });\n  }\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n\n  provideERC20TokenInformation({\n    data\n  }) {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n\n\n  signTransaction(path, rawTxHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response; // Check if the TX is encoded following EIP 155\n\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n    }\n\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response.slice(0, 1).toString(\"hex\");\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    }, e => {\n      throw remapTransactionRelatedErrors(e);\n    });\n  }\n  /**\n   */\n\n\n  getAppConfiguration() {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signPersonalMessage(path, messageHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signEIP712HashedMessage(path, domainSeparatorHex, hashStructMessageHex) {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport.send(0xe0, 0x0c, 0x00, 0x00, buffer).then(response => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n\n\n  starkGetPublicKey(path, boolDisplay) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      return response.slice(0, response.length - 2);\n    });\n  }\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder(path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignTransfer(path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n\n\n  starkProvideQuantum(operationContract, operationQuantization) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n\n}\n//# sourceMappingURL=Eth.js.map","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\nexport function defer() {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n\n  return {\n    promise,\n    resolve,\n    reject\n  };\n} // TODO use bip32-path library\n\nexport function splitPath(path) {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n\n    result.push(number);\n  });\n  return result;\n} // TODO use async await\n\nexport function eachSeries(arr, fun) {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\nexport function foreach(arr, callback) {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else return callback(array[index], index).then(function (res) {\n      result.push(res);\n      return iterate(index + 1, array, result);\n    });\n  }\n\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\nexport function doIf(condition, callback) {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\nexport function asyncWhile(predicate, callback) {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n\n  return Promise.resolve([]).then(iterate);\n}\n//# sourceMappingURL=utils.js.map"]}